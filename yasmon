#!/usr/bin/env python

#########################################################################
# YASMon - Yet Another System Monitor                                   #
# Copyright (C) 2010  Scott Lawrence                                    #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

from optparse import OptionParser
import shlex
import sys
import time

import sysmon,sysmon.local,sysmon.callback

#parse the options
parser=OptionParser(usage="usage: %prog [-d DELAY] [-l | -c]",
                    version=("YASMon "+sysmon.version()+"\n"+
                             "Copyright (C) 2010 Scott Lawrence.\n"+
                             "Licensed under the GNU GPL version 3 or later "+
                             "<http://gnu.org/licenses/gpl.html>.\n"
                             "This is free software: "+
                             "you are free to change and redistribute it.\n"
                             "There is NO WARRANTY, to the "+
                             "extent permitted by law."+
                             "\n\n"+
                             "Written by Scott Lawrence <bytbox@gmail.com>"))
parser.add_option("-c","--curses",
                  action="store_true",dest="curses",
                  help="Display a curses interface")
parser.add_option("-d","--delay",dest="delay",default=5,
                  help="Delay between updates, in seconds (may be decimal). Default: 5")
parser.add_option("--fs-delay",dest="fs_delay",default=120,
                  help="Delay between filesystem updates, in seconds (may be decimal). Default: 120")
parser.add_option("-l","--log",
                  action="store_true",dest="log",
                  help="Log events to standard output")
parser.add_option("-r","--remote",action="store_true",
                  dest="force_remote",help="Force remote mode")
parser.add_option("-r","--local",action="store_true",
                  dest="force_local",help="Force local mode")
(options,args)=parser.parse_args()

#read the configuration file
mode='local'
servers='127.0.0.1'
try:
    fin=open("/etc/yasmon.conf")
    lex=shlex.shlex(fin)
    token=lex.read_token()
    while token!='':
        if token=='mode':
            token=lex.read_token()
            if token=='':
                exit(-1)
            if token=='local' or token=='remote':
                mode=token
        elif token=='servers':
            servers=lex.read_token()
        token=lex.read_token()
    fin.close()
except IOError:
    print "Couldn't read /etc/yasmon.conf"
    sys.exit(1)


#initialize the monitor
#callback
callback=sysmon.callback.SysmonCallback()
def handle_misc_update(data):
    print "misc.updated: ",data
callback.hook("misc.updated",handle_misc_update)
callback.hook("local.misc.updated",
              (lambda data: sys.stdout.write("local.misc.updated\n")))
#just local for now
local=sysmon.local.get_local()
local.set_delay(float(options.delay))
local.set_callback(callback)
#set special delays
for fs in local.filesystems():
    fs.set_delay(float(options.fs_delay))

#start the UI
if options.curses:
    #FIXME
    sys.stderr.write("Curses not supported\n")
    exit(-1)

elif options.log:
    #logging version

    #hooks
    def local_handle_processor_update(name):
        p=local.processor(name)
        print "%s \"%s\": " % (p.name(),p.modelname())
    def local_handle_memory_update(data):
        mem=local.memory()
        print "mem: %f%%" % (100*float(mem.active_memory())/float(mem.total_memory()))

    #register hooks
    callback.hook("local.processor.updated",local_handle_processor_update)
    callback.hook("local.memory.updated",local_handle_memory_update)

    #run
    local.run()
    #now wait
    try:
        while True:
            time.sleep(500)
    except KeyboardInterrupt:
        #stop all the daemons
        local.acquire()
        print "Bye!"


else:
    #GUI Code for YASMon client (uses QT4)
    from PyQt4 import QtCore
    from PyQt4.QtGui import *

    class CPUView(QWidget):
        """A widget to view cpu usage information et al. for a single
        CPU.

        This consists of a simple graphic, with a single vertical
        "progress bar" (labelled as appropriate) and two numbers
        below: the exact percentage usage and the current temperature,
        if available.
        """
        def __init__(self,processor):
            QWidget.__init__(self)
            self.processor=processor
            #add me to the hook

    class ProcessorView(QWidget):
        """A widget to view processor information for multiple
        processors.
        
        This will normally be significantly wider than it is tall, as
        it consists simply of a horizontal row of CPUViews.
        """
        def __init__(self):
            QWidget.__init__(self)
            layout=QHBoxLayout()
            self.setLayout(layout)
            #for each cpu...
            for processor in local.processors():
                layout.addWidget(CPUView(local.processor(processor.name())))

    class MemoryView(QWidget):
        """A widget to display the current memory usage in a memory
        bank (RAM).

        """
        def __init__(self,memory):
            QWidget.__init__(self)
            self.memory=memory

    class OverviewView(QFrame):
        """Displays current information for the most general (and
        critical) parts of the system

        This generally means the processors, memory, and hard disk
        usage.
        """
        def __init__(self):
            QFrame.__init__(self)
            self.setLineWidth(2);
            self.setFrameStyle(self.StyledPanel | QFrame.Raised)
            layout=QHBoxLayout()
            self.setLayout(layout)
            layout.addWidget(ProcessorView())
            layout.addWidget(MemoryView(local.memory()))

    class HistoryView(QFrame):
        """Displays most of OverviewView's content, as a history.

        This view consists of a set of a few graphs, each containing
        in somewhat condensed for the history of some measure of
        performance. A single pixel is used for every related update
        fired.
        """
        def __init__(self):
            QFrame.__init__(self)

    class MainView(QWidget):
        def __init__(self):
            QWidget.__init__(self)
            layout=QVBoxLayout()
            self.setLayout(layout)
            layout.addWidget(OverviewView())
            layout.addWidget(QLabel("ho"))

    class MainWindow(QMainWindow):
        def __init__(self):
            QMainWindow.__init__(self)
            self.createActions()
            self.createMenus()
            self.createLayout()
            self.createStatusBar()

        #actions
        def about(self):
            QMessageBox.about(self, "About YASMon",
                              "<b>YASMon v"+sysmon.version())

        def createActions(self):
            self.aboutAct=QAction("&About YASMon",self,
                                  statusTip="Display YASMon's About box",
                                  triggered=self.about)
            self.aboutQtAct=QAction("About &Qt", self,
                                    statusTip="Show the Qt library's About box",
                                    triggered=qApp.aboutQt)
        
        def createMenus(self):
            self.helpMenu=self.menuBar().addMenu("&Help")
            #FIXME add manual
            self.helpMenu.addSeparator()
            self.helpMenu.addAction(self.aboutAct)
            self.helpMenu.addAction(self.aboutQtAct)
        
        def createLayout(self):
            self.setCentralWidget(MainView())

        def createStatusBar(self):
            self.statusBar().showMessage("Ready")
    
    app = QApplication(sys.argv)
    win = MainWindow()
    win.setWindowTitle("YASMon")
    win.show()
    #run sysmon
    local.run()
    sys.exit(app.exec_())


