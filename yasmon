#!/usr/bin/env python

#########################################################################
# YASMon - Yet Another System Monitor                                   #
# Copyright (C) 2010  Scott Lawrence                                    #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

from optparse import OptionParser
import re,sysmon

#parse the options
parser=OptionParser(usage="usage: %prog [-d DELAY] [-l | -c] [SERVER ...]",
                    version=("YASMon "+sysmon.version()+"\n"+
                             "Copyright (C) 2010 Scott Lawrence.\n"+
                             "Licensed under the GNU GPL version 3 or later "+
                             "<http://gnu.org/licenses/gpl.html>.\n"
                             "This is free software: "+
                             "you are free to change and redistribute it.\n"
                             "There is NO WARRANTY, to the "+
                             "extent permitted by law."+
                             "\n\n"+
                             "Written by Scott Lawrence <bytbox@gmail.com>"))
parser.add_option("-c","--curses",
                  action="store_true",dest="curses",
                  help="Display a curses interface")
parser.add_option("-d","--delay",dest="delay",default=5,
                  help="Delay between updates, in seconds (may be decimal). Default: 5")
parser.add_option("--fs-delay",dest="fs_delay",default=120,
                  help="Delay between filesystem updates, in seconds (may be decimal). Default: 120")
parser.add_option("-l","--log",
                  action="store_true",dest="log",
                  help="Log events to standard output")
parser.add_option("-r","--remote",action="store_true",
                  dest="remote_mode",help="Use remote mode")
parser.add_option("-R","--local",action="store_true",
                  dest="local_mode",help="Use local mode (default)")
(options,args)=parser.parse_args()

mode="local"
if options.remote_mode:
    mode="remote"


#import what we need
import shlex,sys,time
import sysmon.callback
from sysmon.error import *

#import for the mode
if mode=='local':
    import sysmon.local
else:
    import sysmon.remote

#import for the UI setting
#also set appropriate error yandling
if options.curses:
    from sysmon import curses
elif not options.log:
    from sysmon import gui
    app = gui.QApplication(sys.argv)

#initialize the monitor
#callback
callback=sysmon.callback.SysmonCallback()
def handle_misc_update(data):
    print "Miscellaneous update: ",data
callback.hook("misc.updated",handle_misc_update)

#handle strange updates
callback.hook("misc.updated",
              handle_misc_update)


systems={}
if mode=="local":
    local=sysmon.local.get_local()
    local.set_delay(float(options.delay))
    local.set_callback(callback)
    #set special delays
    for fs in local.filesystems():
        fs.set_delay(float(options.fs_delay))
    systems['localhost']=local

elif mode=="remote":
    #note: do NOT assume localhost to be one of the systems!
    if len(args)==0:
        raise CLArgumentError("no remote systems specified")
    for sysname in args:
        match=re.match("^(.+):(.+)$",sysname)
        if match:
            port=int(match.group(2))
            sysname=match.group(1)
        else:
            port=61874
        try:
            system=sysmon.remote.get_remote(sysname,port)
            #set delays
            system.set_delay(float(options.delay))
            for fs in system.filesystems():
                fs.set_delay(float(options.fs_delay))
            systems[sysname]=system
        except IOError as err:
            #could not connect! 
            raise RemoteError(sysname,"could not connect")
            

#start the UI
if options.curses:
    #FIXME implement a decent curses interface, as specified in the
    #man pages
    sys.stderr.write("Curses not supported\n")
    exit(-1)

elif options.log:
    #logging version

    #hooks
    def handle_processor_update(p):
        print "%s: %f" % (p.name(),p.usage()/p.max_freq())
    def handle_memory_update(mem):
        print "mem: %f%%" % (100*float(mem.active_memory())/float(mem.total_memory()))


    #register hooks
    callback.hook("processor.updated",handle_processor_update)
    callback.hook("memory.updated",handle_memory_update)

    #run all systems
    for system in systems:
        systems[system].run()

    #now wait
    try:
        while True:
            time.sleep(500)
    except KeyboardInterrupt:
        #stop all the daemons
        for system in systems:
            systems[system].acquire()
        print "Bye!"


else:
    class MainWindow(gui.QMainWindow):
        """The main YASMon window.
        """
        def __init__(self):
            """Creates the main window.
            """
            gui.QMainWindow.__init__(self)
            self.createActions()
            self.createMenus()
            self.createLayout()
            self.createStatusBar()

        #actions
        def about(self):
            """Displays the about box.
            """
            gui.about_yasmon(self)

        def createActions(self):
            self.aboutAct=gui.QAction("&About YASMon",self,
                                  statusTip="Display YASMon's About box",
                                  triggered=self.about)
            self.aboutAct.setIcon(gui.yasmon_icon())
            self.aboutQtAct=gui.QAction("About &Qt", self,
                                    statusTip="Show the Qt library's About box",
                                    triggered=gui.qApp.aboutQt)
            self.aboutQtAct.setIcon(gui.qt_icon())
        
        def createMenus(self):
            self.helpMenu=self.menuBar().addMenu("&Help")
            #FIXME add manual
            self.helpMenu.addSeparator()
            self.helpMenu.addAction(self.aboutAct)
            self.helpMenu.addAction(self.aboutQtAct)
        
        def createLayout(self):
            self.setCentralWidget(gui.MainView(systems))

        def createStatusBar(self):
            self.statusBar().showMessage("Ready")
            
    win = MainWindow()
    win.setWindowTitle("YASMon")
    win.show()
    #run sysmon
    for system in systems:
        systems[system].run()

    ret=app.exec_()
    #stop all the daemons
    for system in systems:
        systems[system].acquire()
        
    sys.exit(ret)


